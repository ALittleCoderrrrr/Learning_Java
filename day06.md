# Learning_Java_06
## Redis

http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/

Redis（Remote Dictionary Server）是一种开源的内存数据库管理系统，它以键值对（key-value）存储数据（noSQL），并支持多种数据结构，如字符串、列表、集合、哈希表、有序集合等。Redis的特点包括：

1. 内存存储：Redis将数据存储在内存中，因此读写速度非常快，适合用作缓存。

2. 持久化：Redis支持将数据持久化到磁盘，以防止数据丢失。

3. 多种数据结构：除了基本的字符串，Redis还支持列表、集合、哈希表、有序集合等复杂的数据结构，使其能够满足各种不同的应用需求。

4. 发布-订阅模式：Redis支持发布-订阅模式，使多个客户端可以实时订阅并接收特定消息。

5. 事务支持：Redis支持事务，可以一次执行多个命令，保证这些命令的原子性。

6. 高可用性：Redis提供了多种高可用性方案，如主从复制和哨兵模式，以确保系统的可用性和容错性。

7. 支持多种编程语言：Redis有各种编程语言的客户端库，使开发者可以方便地与其交互。

Redis通常用于缓存、会话管理、排行榜、计数器、实时分析等多种应用场景，它的高性能和灵活性使其成为一个流行的数据存储和缓存解决方案。


一个常见的Redis实际使用场景是缓存。当一个应用程序需要频繁读取某些数据时，可以将这些数据存储在Redis中，而不是每次都去查询数据库或其他数据存储系统。这可以显著提高应用程序的性能和响应时间。

例如，考虑一个电子商务网站，用户经常浏览产品目录。产品目录数据不经常更改，因此将产品目录信息存储在Redis缓存中可以极大地减轻数据库的负载。当用户请求产品目录时，应用程序首先检查Redis缓存，如果在缓存中找到数据，就直接返回给用户，而不需要查询数据库。只有当产品目录发生更改时，才会更新Redis缓存。

这个场景中，Redis的优势在于它的快速读取速度和高效的数据结构，适合用作缓存层，减轻后端数据库的压力，提高了网站的性能和用户体验。

除了缓存，Redis还用于会话管理、消息队列、实时计数器、排行榜、发布-订阅系统等多种应用。它的灵活性和性能使其成为各种分布式应用程序的关键组件。

**Redis** 

http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/

是一个高性能的内存键值存储数据库，支持多种数据结构，其中之一就是 **String**，是 Redis 最简单的数据结构之一。下面是关于 Redis String 的原理和一些常见使用场景：

**Redis String 原理：**

- **内部实现**：Redis 的 String 数据结构内部是一个字节数组（byte array），可以存储任意类型的数据，例如文本、二进制数据等。

- **常见操作**：Redis 提供了一系列的命令来操作 String 数据，包括 SET、GET、INCR、DECR、APPEND、GETRANGE 等。

- **持久化**：Redis 可以配置为支持数据持久化，将内存中的数据保存到磁盘，以便在重启后恢复数据。

**Redis String 使用场景：**

1. **缓存**：Redis 中的 String 数据结构常用于缓存。应用程序可以将经常使用的数据存储在 Redis 中，以避免频繁查询数据库，从而提高访问速度。缓存可以存储用户会话、页面内容、频繁查询的数据库查询结果等。

2. **计数器**：Redis 提供了 INCR 和 DECR 命令，用于原子性地增加或减少存储在 String 中的整数值。这使得 Redis 可以用于实现计数器，例如网站上的点赞数、浏览数等。

3. **分布式锁**：String 数据结构可以用于实现分布式锁。通过 SETNX（SET if Not eXists）命令，可以在 Redis 中创建一个键，如果键不存在，则设置成功，从而实现锁。

4. **Session 存储**：将用户会话数据存储在 Redis 中，可以实现分布式应用程序的 Session 共享，提高了应用程序的可扩展性。

5. **消息队列**：Redis 的 String 数据结构可以用于实现消息队列。应用程序将消息存储在 Redis 的 List 结构中，其他应用程序可以通过消费消息列表中的数据来实现简单的消息队列功能。

6. **简单文本存储**：除了缓存和计数器之外，String 数据结构也可以用于存储简单的文本数据，例如配置信息、短链接等。

需要注意的是，Redis 的 String 是一个简单的二进制安全存储，可以存储任何数据，但它并不是适合所有场景的数据结构。在选择使用 Redis String 时，需要考虑数据的大小、持久化需求、并发访问等因素。根据具体的需求，还可以结合 Redis 的其他数据结构来构建更复杂的数据模型。

## Spring
Spring的IoC（Inversion of Control，控制反转）和AOP（Aspect-Oriented Programming，面向切面编程）是Spring框架的两个核心特性，它们的实现原理如下：

1. **IoC（控制反转）实现原理：**

   - **Bean工厂（Factory）：** Spring的IoC容器主要通过Bean工厂来管理Java对象，这些对象被称为"Bean"。Bean工厂是IoC容器的核心，负责实例化、配置、装配Bean。

   - **配置元数据：** Spring通过配置文件（通常是XML文件）或Java注解来定义Bean的配置元数据，包括Bean的类型、依赖关系、初始化方法、销毁方法等。

   - **依赖注入（DI）：** Spring通过依赖注入将Bean的依赖关系从代码中解耦，使得Bean之间的关系由IoC容器来管理。IoC容器负责将依赖的Bean注入到目标Bean中，通常有构造器注入、Setter注入和接口注入等方式。

   - **Bean的生命周期管理：** Spring容器负责管理Bean的生命周期，包括Bean的实例化、初始化、使用和销毁。这通过Bean的作用域、初始化方法和销毁方法来控制。

   - **反射机制：** Spring使用Java的反射机制来实例化和配置Bean，根据配置文件或注解，Spring会使用反射创建Bean的实例。

   - **AOP（面向切面编程）：** IoC容器通常与AOP结合使用，可以通过AOP增强Bean的功能，实现横切关注点的模块化。

2. **AOP（面向切面编程）实现原理：**

   - **代理模式：** AOP的核心是代理模式，Spring使用代理模式在目标对象的方法执行前后插入额外的逻辑。

   - **切面（Aspect）：** 切面是一组通用的横切关注点，通常包括一组通知（Advice）和一个切点（Pointcut）。通知定义了在何时、何地以及如何执行额外的逻辑，切点定义了在何处执行通知。

   - **通知（Advice）：** 通知是AOP中的具体操作，通常包括前置通知（Before Advice）、后置通知（After Advice）、返回通知（After Returning Advice）、异常通知（After Throwing Advice）和环绕通知（Around Advice）等。

   - **目标对象（Target）：** 目标对象是AOP中被代理的原始对象，通知会围绕目标对象的方法执行。

   - **代理对象（Proxy）：** Spring使用代理对象来包装目标对象，代理对象包含了通知逻辑，它在目标对象方法执行前后插入通知。

   - **织入（Weaving）：** 织入是指将切面和目标对象关联起来的过程，它可以在编译时、类加载时或运行时进行。

总的来说，IoC实现了对象的创建、依赖注入和生命周期管理，AOP实现了横切关注点的模块化，它们的核心在于代理机制和反射机制的应用。Spring框架通过这两个特性，使得应用程序的代码更加清晰、模块化、易于维护。

Redis持久化是指将Redis中的数据写入到磁盘上，以确保数据在Redis服务器重启后不会丢失。Redis支持两种主要的持久化方式：RDB（Redis DataBase）和AOF（Append Only File）。

1. **RDB持久化**：
   - RDB持久化是一种快照持久化方式，它将Redis的数据保存为一个二进制文件（通常以.rdb扩展名保存）。
   - RDB可以手动触发，也可以配置成在满足一定条件时自动触发（如在一段时间内有多少次写操作）。
   - 适用于数据备份、迁移、快速恢复等场景。
   - 但它可能会导致数据在最后一次快照和上一次快照之间的部分数据丢失。

    手动触发：

    save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短


2. **AOF持久化**：
   - AOF持久化是一种追加日志文件的方式，它将每次写操作以追加的方式记录到一个日志文件中。
   - AOF文件包含了可以重新构建数据集的所有写操作，因此数据的安全性较高。
   - AOF可以配置成每个写操作都同步到磁盘，或者按一定的条件触发同步操作，以权衡性能和数据安全。
   - 适用于需要实时持久化和数据安全性较高的场景。
   
Redis用户可以根据自己的需求和应用场景选择使用RDB、AOF，或同时启用两者来兼顾性能和数据安全性。持久化是Redis中非常重要的一部分，因为它确保了数据的持久性，即使服务器重启也不会导致数据丢失。

Redis 使用哈希表作为其主要数据结构之一，用于存储键值对。哈希表在 Redis 内部称为字典（dict）。当哈希表中的键值对数量达到一定阈值时，为了保持性能，Redis 会触发重新哈希（rehash）操作。这个操作将创建一个更大的哈希表，然后将已存在的键值对重新散列到新表中。这个过程涉及到以下两个概念：

1. **Rehash（重新哈希）**：在哈希表中，为了保持性能，通常需要在表中存储一些额外的空间，以便在表的大小（桶的数量）接近饱和时，不至于导致查找性能的急剧下降。当哈希表中的键值对数量达到一定阈值时，就会触发重新哈希操作。重新哈希操作会创建一个更大的哈希表，然后将所有已存在的键值对重新散列到新表中。这个过程需要一些时间，但它确保了哈希表仍然能够保持高性能。

2. **渐进式 Rehash（渐进式重新哈希）**：渐进式重新哈希是指在进行重新哈希操作时，系统允许继续执行其他操作，而不会完全阻塞。Redis 采用了渐进式重新哈希的方式，这意味着在重新哈希过程中，仍然可以执行插入、删除和查找等操作。这是通过在新表中建立一个与旧表并行的表格，逐渐将键值对从旧表迁移到新表，直到所有键值对都迁移完成。

渐进式重新哈希的优势在于它不会阻塞整个 Redis 实例，使得即使在重新哈希期间，系统仍然可以提供响应。这在处理大量数据时非常有用，因为在重新哈希操作期间，仍然可以继续对 Redis 进行操作，而不会因为重新哈希而导致性能下降。这也是 Redis 能够保持高性能和可用性的一个关键特性。

Redis缓存穿透是指恶意请求或者非法请求绕过缓存直接访问数据库，导致数据库频繁查询，增加数据库负担。缓存穿透通常发生在以下情况：

1. 请求的数据在数据库中不存在，但是频繁请求。
2. 恶意请求或者攻击者试图绕过缓存查询数据库。

缓存穿透可能会导致数据库负载过高，甚至宕机。为了解决这个问题，可以采取以下解决方案：

1. **布隆过滤器（Bloom Filter）：** 布隆过滤器是一种数据结构，用于判断一个元素是否存在于一个集合中。在查询缓存之前，可以使用布隆过滤器判断请求的数据是否合法。如果布隆过滤器判断数据不存在，可以直接拒绝请求，而不去查询数据库。

2. **缓存空对象（Cache Null Values）：** 如果查询数据库后发现数据不存在，可以将这个结果也缓存起来，但是设置一个较短的过期时间。这样在一段时间内，相同的请求会命中缓存，减轻数据库负担。


缓存击穿是指一个缓存中不存在但是频繁被请求的数据，每次请求都需要查询数据库，这会导致数据库负载过高，甚至宕机。通常情况下，缓存击穿发生在以下情况下：

1. **热点数据失效：** 一个热点数据在缓存中失效，而此时有大量请求同时涌入，导致缓存未命中，都去查询数据库。

2. **定时过期：** 缓存中的数据设置了固定的过期时间，在数据过期后，如果有大量请求同时到来，就会触发缓存击穿。

为了解决缓存击穿问题，可以采取以下策略：

1. **使用互斥锁（Mutex Lock）：** 当一个请求发现缓存失效时，可以尝试获取一个互斥锁。只有一个请求能够成功获取锁，其他请求需要等待。获取锁的请求负责查询数据库并更新缓存，其他请求等待锁释放后，可以直接从缓存中获取数据。这种方式可以保证只有一个请求查询数据库，避免了大量请求同时击穿缓存。

2. **使用永不过期策略：** 对于热点数据，可以采用永不过期的策略，即不设置缓存的过期时间。但需要考虑内存的管理和数据的实时性。

